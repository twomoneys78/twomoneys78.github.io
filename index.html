<html>
<head>
<meta charset="utf-8">
<script src="gpu-browser.min.js"></script>

</head>
<body>
<h1>Progress : <span id="abc"></span></h1>

<script>

let ___random = Math.random
let randoms = new Float32Array(10000)
for(let i = 0;i < randoms.length;++i) randoms[i] = ___random()

let randomi = 0

Math.random = function() {
	return randoms[randomi++]
}

let bads = []
//let goods = [];

	function mypow(x,y) {
		return Math.sign(x) * Math.pow(Math.abs(x),y);
	}
	
function clamp(x) {
	if(x > 1) return 1
	if(x < 0) return 0
	return x
}

function nextsong() {
    let song = new Float32Array(randoms.length);
    for (let i = 0; i < randoms.length; ++i) {
        song[i] = ___random();
    }

    if (bads.length > 0) {  // Länge prüfen, um den Block auszuführen
        for (let iteration = 0; iteration < 100; ++iteration) {
            let vsum = new Float32Array(randoms.length);
			for(let i = 0;i < vsum.length;++i) vsum[i] = 0

            bads.forEach((b, badIndex) => {
                let v = new Float32Array(randoms.length);
 				for(let i = 0;i < v.length;++i) v[i] = 0
				let sum = 0;

                for (let i = 0; i < v.length; ++i) {
                    v[i] = b[i] - song[i];
                    sum += Math.abs(v[i]);
                }

                sum /= v.length;

                if (sum < 1e-6) {
                    sum = 1e-6;
                }

                let weight = Math.exp(-5 * sum);

                for (let i = 0; i < v.length; ++i) {
                    vsum[i] -= v[i] * weight;
                }
            });

            let learningRate = 0.01 / (1 + iteration * 0.1);

            for (let i = 0; i < song.length; ++i) {
                song[i] += learningRate * vsum[i] / bads.length;
                song[i] += 0.001 * (___random() - 0.5);
            }
        }
    }

    for (let i = 0; i < song.length; ++i) {
        song[i] = clamp(song[i]);
    }

    randomi = 0;
    randoms = song.slice();
    document.getElementById("bads").innerHTML = bads.length;
    console.log("Optimized song: ", song[0]);
}



/*
function rategood() {
	goods.push(randoms.slice())
	document.getElementById("rate").style.visibility = "hidden"
}
*/

let playingrandoms;

function ratebad() {
	bads.push(playingrandoms.slice())
	document.getElementById("rate").style.visibility = "hidden"
	source.stop()
}

var audioCtx = new (window.AudioContext || window.webkitAudioContext)();

var scale = new Array(18);

function rand(n) {
return Math.floor(n * Math.random() * 0.99);
}	
	
function shuffle(xs) {
xs = xs.slice(0);

var ys = [];

while(xs.length > 0) {
var i = rand(xs.length);
ys.push(xs[i]);
xs.splice(i,1);
}

return ys;
}





class Instrument {

//per instrument
constructor(tone,cvName,waveFunction) {
	this.tone = tone

	let leftVol = Math.random();
	this.chVols = [leftVol,1.0 - leftVol];

	this.rands = new Float32Array(256);
	for(let i = 0;i < this.rands.length;++i) this.rands[i] = 0.5 * Math.random() + 0.25;
	this.wave = waveFunction
	
	if(cvName) {
		let xs = this.wave(audioCtx.sampleRate,0,this.rands,0.25);
		console.log(this.rands[0] + " " + this.rands[1] + " " + this.rands[2])
		let cv = document.getElementById(cvName);
		console.log(cv);
		let ctx = cv.getContext("2d");
		ctx.fillStyle = "black";
		ctx.fillRect(0,0,cv.width,cv.height);
		ctx.strokeStyle = "white";
		ctx.beginPath();
		ctx.lineWidth = 1
		ctx.moveTo(0,0);
		for(let i = 0;i < xs.length;++i) ctx.lineTo(cv.width * i / xs.length,cv.height * (xs[i] + 1) / 2);
		ctx.stroke();
	}
}

//per tone
render(buffer,offset,tone,duration,vol) {
	const n = rand(1024);
	const channels = 2;
	for(var channel = 0; channel < channels; channel++) {
	var nowBuffering = buffer.getChannelData(channel);
	var xs = this.wave(audioCtx.sampleRate,this.tone + tone,this.rands,duration);
	for(let i = 0;i < xs.length;++i) if(i + offset + n < nowBuffering.length) nowBuffering[i + offset + n] += xs[i] * 0.1 * vol * this.chVols[channel];
}	
}
}   


function sc2scale(sc,x0) {
	let scale = [x0]
	for(let i = 0;i < sc.length;++i) scale.push(scale[i] + sc[i]);
	return scale
}

let sc = [2,2,1,2,2,2,1]

function makeScale() {
sc = [2,2,1,2,2,2,1]
let n = rand(sc.length)
for(let i = 0;i < n;++i) sc.unshift(sc.pop())
sc = sc.concat(sc)

scale = sc2scale(sc,rand(12) - 6)
document.getElementById("scale").innerHTML = "[" + scale + "]";
}

class Melody {
constructor(stepSize,instrument) {
this.stepSize = stepSize;
this.instrument = instrument;
this.index = 0;
	this.i = 0;
this.min = rand(scale.length);
this.max = rand(scale.length);
this.r = Math.random();
this.r2 = Math.random();
this.note = 0;
	
}

play(buffer,offset) {
let vs = [1.5,0.5,0.75,0.5,1,0.5,0.75,0.5];
let i = this.i % vs.length;

if(this.i % (vs.length * 4) == 0) {
this.min = rand(scale.length);
this.max = rand(scale.length);	
	
	 }
	 
	let note = this.min + rand(this.max -  this.min);
	let duration = Math.random()
	
switch(rand(3)) {
	    case 0:
		break;
	   case 1:
		this.note = note
	   case 2:
		this.instrument.render(buffer,offset,scale[this.note],duration,vs[i]);
}
	
this.i += 1;
}
}

var channels = 2;
var seconds = 60;
var frameCount = audioCtx.sampleRate * seconds;
let bl = null;
var myArrayBuffer;
var ms;
var playing = false;
var computing = false;
var source;
	
function play() {
window.setTimeout(() => {
if(!playing && !computing) {
// Get an AudioBufferSourceNode.
// This is the AudioNode to use when we want to play an AudioBuffer
//for(let i = 0;i < channels;++i) myArrayBuffer.copyToChannel(bl(myArrayBuffer.getChannelData(i)),i);

source = audioCtx.createBufferSource();
source.onended = () => {playing = false};
// set the buffer in the AudioBufferSourceNode
source.buffer = myArrayBuffer;
// connect the AudioBufferSourceNode to the
// destination so we can hear the sound

source.connect(audioCtx.destination);
source.start();
playingrandoms = randoms.slice()
document.getElementById("cscale").innerHTML = document.getElementById("scale").innerHTML;
document.getElementById("cv2").src = document.getElementById("cv1").toDataURL();
document.getElementById("cv22").src = document.getElementById("cv11").toDataURL();
document.getElementById("cv222").src = document.getElementById("cv111").toDataURL();
//document.getElementById("rate").style.visibility = "visible"
playing = true;

sound();
} else window.setTimeout(play,10);
},10);
}

function make() {
var sum = 0;

ms.forEach((m) => {sum += m.i});

var perc = sum * 100 / frameCount / ms.length;

document.getElementById("abc").innerHTML = perc + "%";

if(perc < 100) {

// 1 Takte
for(let k = 0;k < 4;++k) {
ms.forEach((m,j) => {
if(m.i < frameCount) {
m.play(myArrayBuffer,m.i);
m.i += Math.round(speed * m.stepSize * audioCtx.sampleRate);
} else m.i = frameCount;
});
}

window.setTimeout(make,10);
} else {
computing = false;
play();
}
}

var speed;

function sound() {

	nextsong()
	
	let bpm = 60 + Math.random() * 60
//speed = 0.15 + 0.2 * Math.random();
	speed = 0.175 + Math.random() * 0.11
//alert(speed) 

	
window.setTimeout(() => {
if(!computing) {
computing = true;

makeScale();

seconds = parseInt(document.getElementById("sec").value);
frameCount = audioCtx.sampleRate * seconds;
myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);

ms = [];

//Begleitung
	ins = new Instrument(-12,"cv1",wave);
for(let i = 0;i < 3;++i)
{

	ms.push(new Melody(2,ins));
}


//Sound
	ins = new Instrument(0,"cv11",wave);
for(let i = 0;i < 3;++i) {

	
	ms.push(new Melody(1,ins));
}

//Bongos
	ins = new Instrument(0,"cv111",bongo);
for(let i = 0;i < 3;++i) {

	
	ms.push(new Melody(1,ins));
}

make();
} else window.setTimeout(sound,10);
},10);
}

	let normalize = function(xs) {
		var max = -1000000;
		var min = 1000000;
		for(let i = 0;i < xs.length;++i) if(xs[i] > max) max = xs[i]; else if(xs[i] < min) min = xs[i];
		var a = Math.max(Math.abs(max),Math.abs(min));
		for(let i = 0;i < xs.length;++i) xs[i] = 2 * (xs[i] - min) / (max - min) - 1;
		return xs;
	};

    const gpu = new GPU();
    
	gpu.addFunction(mypow)
	
	gpu.addFunction(function sawtooth(x) {
	  let y = x / Math.PI * 2;
	  return 2 * (y - Math.floor(y)) - 1;
	});
	
	let bongoGPU = gpu.createKernel(function(len,tone,rands,duration) {		
		let omega = 440.0 * this.thread.x / len * Math.pow(2.0,(0 + tone - 12) / 12.0) * Math.PI;
		let omega2 = 50.0 * this.thread.x / len * Math.PI;
				
  		let vibratoa = Math.sin(2 * Math.PI * 3 * rands[12] * this.thread.x / len) * rands[13] * 3;
 		let vibratob = Math.sin(2 * Math.PI * 3 * rands[14] * this.thread.x / len) * rands[15] * 3;
 		let vibratoc = Math.sin(2 * Math.PI * 3 * rands[16] * this.thread.x / len) * rands[17] * 3;

		let a = 0.0
		a += rands[0] * mypow(Math.sin(omega + vibratoa),rands[30] + 1);
		a += rands[1] * Math.sign(Math.sin(omega + vibratoa));
		a += rands[2] * sawtooth(omega + vibratoa);
		a /= rands[0] + rands[1] + rands[2]
		
		let b = rands[3] * mypow(Math.sin(omega / 2 + vibratob),rands[31] + 1);
		b += rands[4] * Math.sign(Math.sin(omega / 2 + vibratob));
		b += rands[5] * sawtooth(omega / 2 + vibratob);
		b /= rands[3] + rands[4] + rands[5]
		
		let c = rands[6] * mypow(Math.cos(omega2 + vibratoc),rands[32] + 1);
		c += rands[7] * Math.sign(Math.cos(omega2 + vibratoc));
		c += rands[8] * sawtooth(omega2 + vibratoc);
		c /= rands[6] + rands[7] + rands[8]
		
		let d = rands[9] * a + rands[10] * 0.5 * b + rands[11] * 0.25 * c
		d /= rands[9] + rands[10] * 0.5 + rands[11] * 0.25
		
		d *= (Math.atan(-(4 + 80 * rands[129]) * (this.thread.x / len - duration / 4)) + Math.PI / 2) / Math.PI
		
		return d
 	}).setOutput([audioCtx.sampleRate / 2]); // over 1 second

	let bongo = function(len,tone,rands,duration) {
		let xs = bongoGPU(len,tone,rands,duration)
		
		return normalize(xs);
	}
	
	let wave = function(len,tone,rands,duration) {
		let xs = waveGPU(len,tone,rands,duration)
		
		return normalize(xs);
	}
	
	let waveGPU = gpu.createKernel(function(len,tone,rands,duration) {		
		let omega = 440.0 * this.thread.x / len * Math.pow(2.0,(0 + tone) / 12.0) * Math.PI;
				
  		let vibratoa = Math.sin(2 * Math.PI * 3 * rands[12] * this.thread.x / len) * rands[13] * 3
 		let vibratob = Math.sin(2 * Math.PI * 3 * rands[14] * this.thread.x / len) * rands[15] * 3
 		let vibratoc = Math.sin(2 * Math.PI * 3 * rands[16] * this.thread.x / len) * rands[17] * 3

		let a = 0.0
		a += rands[0] * mypow(Math.sin(omega + vibratoa),2 * rands[30] + 1);
		a += rands[1] * Math.sign(Math.sin(omega + vibratoa));
		a += rands[2] * sawtooth(omega + vibratoa);
		a /= rands[0] + rands[1] + rands[2]
		
		let b = rands[3] * mypow(Math.sin(omega * 2 + vibratob),2 * rands[31] + 1);
		b += rands[4] * Math.sign(Math.sin(omega * 2 + vibratob));
		b += rands[5] * sawtooth(omega * 2 + vibratob);
		b /= rands[3] + rands[4] + rands[5]
		
		let c = rands[6] * mypow(Math.sin(omega * 3 + vibratoc),2 * rands[32] + 1);
		c += rands[7] * Math.sign(Math.sin(omega * 3 + vibratoc));
		c += rands[8] * sawtooth(omega * 3 + vibratoc);
		c /= rands[6] + rands[7] + rands[8]
		
		let d = rands[9] * a + rands[10] * 0.5 * b + rands[11] * 0.25 * c
		d /= rands[9] + rands[10] * 0.5 + rands[11] * 0.25
		
		d *= (Math.atan(-(4 + 80 * rands[129]) * (this.thread.x / len - duration)) + Math.PI / 2) / Math.PI
		
		return d
 	}).setOutput([audioCtx.sampleRate / 2]); // over 1 second




	
</script>
<br>
<button onclick="this.style.visibility='hidden';sound()" style='width:25%;height:25%;font-size:3em;position:absolute;'>Sound</button>
<button onclick="source.stop()" style='width:25%;height:25%;font-size:3em'>Next please</button>
<br>
Seconds : 
<select id="sec">
<option value="30" >30</option>
<option value="60" selected >60</option>
<option value="120" >120</option>
<option value="180">180</option>
</select>
<!--
Fancy Random : <input type="checkbox" id="fr">
-->
<fieldset>
<legend>Upcoming Data</legend>
<br>
scale : <span id="scale"></span>
<br>
<canvas width=800 height=800 style="width:30%;height:200px" id="cv1"></canvas>
<canvas width=800 height=800 style="width:30%;height:200px" id="cv11"></canvas>
<canvas width=800 height=800 style="width:30%;height:200px" id="cv111"></canvas>
</fieldset>


<fieldset>
<legend>Current Data</legend>
<!--<fieldset id="rate" style="visibility:hidden">
<legend>
Rate this song
</legend>
<button onclick="ratebad()"  style='width:25%;height:25%;font-size:3em'>bad</button>
<button onclick="rategood()"  style='width:25%;height:25%;font-size:3em'>GOOD</button>
</fieldset>-->
<br>
scale : <span id="cscale"></span>
<br>
<img width=800 height=800 style="width:30%;height:200px" id="cv2"></canvas>
<img width=800 height=800 style="width:30%;height:200px" id="cv22"></canvas>
<img width=800 height=800 style="width:30%;height:200px" id="cv222"></canvas>
</fieldset>
<fieldset><legend>number of bad songs</legend><span id="bads"></span></fieldset>
<!--<fieldset><legend>number of good songs</legend><span id="goods"></span></fieldset>-->
</body>
</html>



